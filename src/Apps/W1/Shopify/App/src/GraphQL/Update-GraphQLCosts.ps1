<#
.SYNOPSIS
    Updates GraphQL codeunits with actual costs from the CSV analysis file.

.DESCRIPTION
    This script:
    1. Reads the CSV file generated by Analyze-GraphQLCosts.ps1
    2. For each file with a cost mismatch, updates the GetExpectedCost() method
    3. Preserves the original file structure and formatting
    4. Creates a backup before making changes

.PARAMETER CsvPath
    Path to the CSV file containing the cost analysis results

.PARAMETER BackupFolder
    Path to store backup files (default: "Backup_<timestamp>")

.PARAMETER Force
    If specified, skips confirmation prompts

.EXAMPLE
    .\Update-GraphQLCosts.ps1 -CsvPath "graphql-costs-analysis.csv"

.EXAMPLE
    .\Update-GraphQLCosts.ps1 -CsvPath "graphql-costs-analysis.csv" -Force
#>

param(
    [Parameter(Mandatory = $true)]
    [string]$CsvPath,
    
    [Parameter(Mandatory = $false)]
    [string]$BackupFolder,
    
    [Parameter(Mandatory = $false)]
    [switch]$Force
)

# Function to update the expected cost in a file
function Update-ExpectedCostInFile {
    param(
        [string]$FilePath,
        [int]$OldCost,
        [int]$NewCost
    )
    
    try {
        $content = Get-Content -Path $FilePath -Raw
        
        # Pattern to find and replace the cost value in GetExpectedCost method
        # This pattern matches variations of the exit statement
        $pattern = "(procedure\s+GetExpectedCost\(\)[^\{]*\{[^}]*exit\s*\(\s*)(\d+)(\s*\)\s*;)"
        
        if ($content -match $pattern) {
            $currentCost = [int]$matches[2]
            
            if ($currentCost -ne $OldCost) {
                Write-Warning "  Expected cost in file ($currentCost) doesn't match CSV value ($OldCost). Skipping."
                return $false
            }
            
            $newContent = $content -replace $pattern, "`${1}$NewCost`$3"
            
            Set-Content -Path $FilePath -Value $newContent -NoNewline -Encoding UTF8
            return $true
        }
        else {
            Write-Warning "  Could not find GetExpectedCost pattern in file"
            return $false
        }
    }
    catch {
        Write-Error "  Error updating file: $($_.Exception.Message)"
        return $false
    }
}

# Function to create backup
function New-Backup {
    param(
        [string]$SourcePath,
        [string]$BackupPath
    )
    
    try {
        if (-not (Test-Path $BackupPath)) {
            New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        }
        
        $fileName = Split-Path $SourcePath -Leaf
        $backupFile = Join-Path $BackupPath $fileName
        Copy-Item -Path $SourcePath -Destination $backupFile -Force
        return $true
    }
    catch {
        Write-Error "Error creating backup: $($_.Exception.Message)"
        return $false
    }
}

# Main script
Write-Host "GraphQL Cost Updater" -ForegroundColor Green
Write-Host "=====================`n" -ForegroundColor Green

# Validate CSV file exists
if (-not (Test-Path $CsvPath)) {
    Write-Error "CSV file not found: $CsvPath"
    exit 1
}

# Read CSV
Write-Host "Reading CSV file: $CsvPath" -ForegroundColor Cyan
$data = Import-Csv -Path $CsvPath

# Filter items that need updates (excluding errors and matches)
$itemsToUpdate = $data | Where-Object { 
    ($_.Status -eq "Underestimated" -or $_.Status -eq "Overestimated") -and 
    $_.ActualCost -ne "Error" -and 
    $_.ActualCost -ne "N/A" 
}

if ($itemsToUpdate.Count -eq 0) {
    Write-Host "No files need cost updates. All costs are accurate!" -ForegroundColor Green
    exit 0
}

Write-Host "Found $($itemsToUpdate.Count) files that need cost updates`n" -ForegroundColor Yellow

# Display what will be updated
Write-Host "Files to be updated:" -ForegroundColor Cyan
foreach ($item in $itemsToUpdate) {
    $color = if ($item.Status -eq "Underestimated") { "Red" } else { "Yellow" }
    Write-Host "  $($item.FileName): $($item.ExpectedCost) -> $($item.ActualCost)" -ForegroundColor $color
}

# Confirm with user unless -Force is specified
if (-not $Force) {
    Write-Host "`nDo you want to proceed with updating these files? (Y/N): " -ForegroundColor Yellow -NoNewline
    $confirmation = Read-Host
    if ($confirmation -ne "Y" -and $confirmation -ne "y") {
        Write-Host "Operation cancelled by user." -ForegroundColor Yellow
        exit 0
    }
}

# Setup backup folder
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
if ([string]::IsNullOrEmpty($BackupFolder)) {
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $BackupFolder = Join-Path $scriptPath "Backup_$timestamp"
}

Write-Host "`nCreating backups in: $BackupFolder" -ForegroundColor Cyan
if (-not (Test-Path $BackupFolder)) {
    New-Item -Path $BackupFolder -ItemType Directory -Force | Out-Null
}

# Get the Codeunits folder path
$codeunitsPath = Join-Path $scriptPath "Codeunits"

if (-not (Test-Path $codeunitsPath)) {
    Write-Error "Codeunits folder not found at: $codeunitsPath"
    exit 1
}

# Process updates
$successCount = 0
$failCount = 0

Write-Host "`nUpdating files..." -ForegroundColor Cyan

foreach ($item in $itemsToUpdate) {
    $fileName = $item.FileName
    $filePath = Join-Path $codeunitsPath $fileName
    $oldCost = [int]$item.ExpectedCost
    $newCost = [int]$item.ActualCost
    
    Write-Host "`nProcessing: $fileName" -ForegroundColor Yellow
    Write-Host "  Current Cost: $oldCost" -ForegroundColor Gray
    Write-Host "  New Cost:     $newCost" -ForegroundColor Gray
    
    if (-not (Test-Path $filePath)) {
        Write-Warning "  File not found: $filePath"
        $failCount++
        continue
    }
    
    # Create backup
    Write-Host "  Creating backup..." -ForegroundColor Gray
    if (-not (New-Backup -SourcePath $filePath -BackupPath $BackupFolder)) {
        Write-Warning "  Backup failed. Skipping this file."
        $failCount++
        continue
    }
    
    # Update the file
    Write-Host "  Updating cost..." -ForegroundColor Gray
    if (Update-ExpectedCostInFile -FilePath $filePath -OldCost $oldCost -NewCost $newCost) {
        Write-Host "  Successfully updated!" -ForegroundColor Green
        $successCount++
    }
    else {
        Write-Warning "  Update failed"
        $failCount++
        
        # Restore from backup if update failed
        Write-Host "  Restoring from backup..." -ForegroundColor Gray
        $backupFile = Join-Path $BackupFolder $fileName
        if (Test-Path $backupFile) {
            Copy-Item -Path $backupFile -Destination $filePath -Force
            Write-Host "  Restored from backup" -ForegroundColor Yellow
        }
    }
}

# Summary
Write-Host "`n=== UPDATE SUMMARY ===" -ForegroundColor Green
Write-Host "Total files processed:  $($itemsToUpdate.Count)" -ForegroundColor Cyan
Write-Host "Successfully updated:   $successCount" -ForegroundColor Green
Write-Host "Failed:                 $failCount" -ForegroundColor Red
Write-Host "Backups stored in:      $BackupFolder" -ForegroundColor Cyan

if ($successCount -gt 0) {
    Write-Host "`nIMPORTANT: Review the changes and test thoroughly before committing!" -ForegroundColor Yellow
}
